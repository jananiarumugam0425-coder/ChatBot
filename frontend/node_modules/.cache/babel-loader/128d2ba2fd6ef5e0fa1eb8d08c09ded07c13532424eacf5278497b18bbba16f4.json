{"ast":null,"code":"var _jsxFileName = \"E:\\\\Employee Timesheet chatbot\\\\frontend\\\\src\\\\components\\\\ChatPage\\\\ChatPage.jsx\",\n  _s = $RefreshSig$();\n// src/components/ChatPage/ChatPage.jsx\n\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport './ChatPage.css';\nimport ChatPageView from './ChatPageView';\nimport { v4 as uuidv4 } from 'uuid'; // Requires: npm install uuid\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst API_BASE_URL = 'http://127.0.0.1:5000';\nconst ChatPage = ({\n  user,\n  sessionToken,\n  onSignOut\n}) => {\n  _s();\n  // --- NEW STATE for History and Current Chat ---\n  const [chatList, setChatList] = useState([]); // Stores [{ id, title }, ...]\n  const [currentChatId, setCurrentChatId] = useState(null); // The ID of the currently active chat\n  const initialLoadRef = useRef(true); // Helper to track the very first load\n\n  // --- Existing State ---\n  const [messages, setMessages] = useState([]);\n  const [input, setInput] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState('');\n  const chatEndRef = useRef(null);\n\n  // Scroll to the bottom of the chat area when messages change\n  useEffect(() => {\n    var _chatEndRef$current;\n    (_chatEndRef$current = chatEndRef.current) === null || _chatEndRef$current === void 0 ? void 0 : _chatEndRef$current.scrollIntoView({\n      behavior: \"smooth\"\n    });\n  }, [messages]);\n\n  // A. Starts a new chat session\n  const handleNewChat = () => {\n    const newId = uuidv4();\n    // Add a temporary entry to the list (backend will confirm title on first message)\n    // We ensure the new chat is at the top of the list\n    setChatList(prev => [{\n      id: newId,\n      title: 'New Chat'\n    }, ...prev.filter(c => c.id !== newId)]);\n    setCurrentChatId(newId);\n    setMessages([]);\n    setError('');\n    setInput('');\n  };\n\n  // 1. Fetch the list of past chats\n  const fetchChatList = useCallback(async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/chats`, {\n        // API ROUTE 1\n        headers: {\n          'Authorization': `Bearer ${sessionToken}`\n        }\n      });\n      if (response.status === 401) {\n        onSignOut();\n        return;\n      }\n      if (!response.ok) {\n        throw new Error(\"API call failed.\");\n      }\n      const data = await response.json();\n      setChatList(data.chats || []);\n\n      // On initial load logic (only runs once)\n      if (initialLoadRef.current) {\n        if (data.chats.length > 0) {\n          setCurrentChatId(data.chats[0].id); // Load the most recent chat\n        } else {\n          handleNewChat(); // Start a new one if the list is empty\n        }\n        initialLoadRef.current = false;\n      }\n    } catch (err) {\n      console.error(\"Error fetching chat list:\", err);\n      setError(\"Failed to load chat history. Starting a new chat.\");\n\n      // ðŸ›‘ CRITICAL STABILIZATION: Start a new chat if fetching history fails\n      if (initialLoadRef.current) {\n        handleNewChat();\n        initialLoadRef.current = false;\n      }\n    }\n  }, [sessionToken, onSignOut]);\n\n  // 2. Fetch messages for a specific chat ID\n  const fetchMessages = useCallback(async chatId => {\n    if (!chatId) return;\n    setIsLoading(true);\n    setMessages([]); // Clear old messages immediately\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/chats/${chatId}/messages`, {\n        // API ROUTE 2\n        headers: {\n          'Authorization': `Bearer ${sessionToken}`\n        }\n      });\n      if (response.status === 401) {\n        onSignOut();\n        return;\n      }\n      if (!response.ok) {\n        throw new Error(`Failed to fetch messages.`);\n      }\n      const data = await response.json();\n      setMessages(data.messages || []);\n      setError('');\n    } catch (err) {\n      console.error(\"Error fetching messages:\", err);\n      setError(err.message);\n      setMessages([]);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionToken, onSignOut]);\n\n  // 3. Delete a chat\n  const handleDeleteChat = async chatIdToDelete => {\n    if (!window.confirm(\"Are you sure you want to delete this chat history?\")) return;\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/chats/${chatIdToDelete}`, {\n        // API ROUTE 3\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bearer ${sessionToken}`\n        }\n      });\n      if (response.status === 401) {\n        onSignOut();\n        return;\n      }\n      if (!response.ok) {\n        throw new Error(\"Failed to delete chat.\");\n      }\n\n      // Update local state\n      setChatList(prev => prev.filter(chat => chat.id !== chatIdToDelete));\n\n      // If the deleted chat was the current one, start a new chat\n      if (chatIdToDelete === currentChatId) {\n        setCurrentChatId(null);\n        handleNewChat();\n      }\n    } catch (err) {\n      console.error(\"Error deleting chat:\", err);\n      setError(\"Failed to delete chat history.\");\n    }\n  };\n\n  // B. Logic to load chat list on mount\n  useEffect(() => {\n    if (sessionToken) {\n      fetchChatList();\n    }\n  }, [sessionToken, fetchChatList]);\n\n  // C. Logic to load messages when currentChatId changes\n  useEffect(() => {\n    if (currentChatId) {\n      fetchMessages(currentChatId);\n    }\n  }, [currentChatId, fetchMessages]);\n\n  // --- Core Chat Handlers (Modified to use currentChatId) ---\n\n  const handleSendMessage = async e => {\n    e.preventDefault();\n    const message = input.trim();\n    if (!message || isLoading || !currentChatId) return; // Ensures valid ID exists\n\n    setIsLoading(true);\n    setInput('');\n    const userMessage = {\n      sender: 'user',\n      text: message,\n      timestamp: new Date().toISOString()\n    };\n    setMessages(prev => [...prev, userMessage]);\n    try {\n      var _chatList$find;\n      const response = await fetch(`${API_BASE_URL}/api/chat`, {\n        // Existing chat API\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${sessionToken}`\n        },\n        body: JSON.stringify({\n          message,\n          chat_id: currentChatId\n        }) // SEND the unique chat_id\n      });\n      if (response.status === 401) {\n        onSignOut();\n        return;\n      }\n      const data = await response.json();\n      if (!response.ok) {\n        throw new Error(data.error || 'Chat response failed.');\n      }\n      const botMessage = {\n        sender: 'bot',\n        text: data.response,\n        timestamp: new Date().toISOString()\n      };\n      setMessages(prev => [...prev, botMessage]);\n\n      // If this was a new chat, update the title in the list\n      if (((_chatList$find = chatList.find(c => c.id === currentChatId)) === null || _chatList$find === void 0 ? void 0 : _chatList$find.title) === 'New Chat') {\n        setChatList(prev => prev.map(chat => chat.id === currentChatId ? {\n          ...chat,\n          title: data.chat_title || message.substring(0, 25)\n        } : chat));\n      }\n    } catch (err) {\n      console.error(err);\n      setError(err.message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // File upload must also be associated with the current chat ID\n  const handleFileUpload = async file => {\n    if (isLoading || !currentChatId) return; // Ensures valid ID exists\n\n    setIsLoading(true);\n    setError('');\n    const formData = new FormData();\n    formData.append('file', file);\n    formData.append('chat_id', currentChatId); // SEND the unique chat_id\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/upload`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${sessionToken}`\n        },\n        body: formData\n      });\n      if (response.status === 401) {\n        onSignOut();\n        return;\n      }\n      const data = await response.json();\n      if (!response.ok) {\n        throw new Error(data.error || 'File upload failed.');\n      }\n      const botMessage = {\n        sender: 'bot',\n        text: data.message,\n        timestamp: new Date().toISOString()\n      };\n      setMessages(prev => [...prev, botMessage]);\n    } catch (err) {\n      console.error(err);\n      setError(err.message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Consolidate props for the view component\n  const viewProps = {\n    user,\n    messages,\n    input,\n    setInput,\n    isLoading,\n    error,\n    chatEndRef,\n    onSignOut,\n    handleSendMessage,\n    handleFileUpload,\n    // NEW History Props\n    currentChatId,\n    chatList,\n    setCurrentChatId,\n    // onSelectChat\n    handleNewChat,\n    onDeleteChat: handleDeleteChat\n  };\n  return /*#__PURE__*/_jsxDEV(ChatPageView, {\n    ...viewProps\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 246,\n    columnNumber: 9\n  }, this);\n};\n_s(ChatPage, \"ovEv78nkNv9/PyHRdWMYXT+9M9k=\");\n_c = ChatPage;\nexport default ChatPage;\nvar _c;\n$RefreshReg$(_c, \"ChatPage\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","ChatPageView","v4","uuidv4","jsxDEV","_jsxDEV","API_BASE_URL","ChatPage","user","sessionToken","onSignOut","_s","chatList","setChatList","currentChatId","setCurrentChatId","initialLoadRef","messages","setMessages","input","setInput","isLoading","setIsLoading","error","setError","chatEndRef","_chatEndRef$current","current","scrollIntoView","behavior","handleNewChat","newId","prev","id","title","filter","c","fetchChatList","response","fetch","headers","status","ok","Error","data","json","chats","length","err","console","fetchMessages","chatId","message","handleDeleteChat","chatIdToDelete","window","confirm","method","chat","handleSendMessage","e","preventDefault","trim","userMessage","sender","text","timestamp","Date","toISOString","_chatList$find","body","JSON","stringify","chat_id","botMessage","find","map","chat_title","substring","handleFileUpload","file","formData","FormData","append","viewProps","onDeleteChat","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["E:/Employee Timesheet chatbot/frontend/src/components/ChatPage/ChatPage.jsx"],"sourcesContent":["// src/components/ChatPage/ChatPage.jsx\r\n\r\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\r\nimport './ChatPage.css'; \r\nimport ChatPageView from './ChatPageView'; \r\nimport { v4 as uuidv4 } from 'uuid'; // Requires: npm install uuid\r\n\r\nconst API_BASE_URL = 'http://127.0.0.1:5000';\r\n\r\nconst ChatPage = ({ user, sessionToken, onSignOut }) => {\r\n    // --- NEW STATE for History and Current Chat ---\r\n    const [chatList, setChatList] = useState([]); // Stores [{ id, title }, ...]\r\n    const [currentChatId, setCurrentChatId] = useState(null); // The ID of the currently active chat\r\n    const initialLoadRef = useRef(true); // Helper to track the very first load\r\n    \r\n    // --- Existing State ---\r\n    const [messages, setMessages] = useState([]);\r\n    const [input, setInput] = useState('');\r\n    const [isLoading, setIsLoading] = useState(false);\r\n    const [error, setError] = useState('');\r\n    const chatEndRef = useRef(null);\r\n\r\n    // Scroll to the bottom of the chat area when messages change\r\n    useEffect(() => {\r\n        chatEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\r\n    }, [messages]);\r\n    \r\n    // A. Starts a new chat session\r\n    const handleNewChat = () => {\r\n        const newId = uuidv4();\r\n        // Add a temporary entry to the list (backend will confirm title on first message)\r\n        // We ensure the new chat is at the top of the list\r\n        setChatList(prev => [{ id: newId, title: 'New Chat' }, ...prev.filter(c => c.id !== newId)]);\r\n        setCurrentChatId(newId);\r\n        setMessages([]);\r\n        setError('');\r\n        setInput('');\r\n    };\r\n\r\n\r\n    // 1. Fetch the list of past chats\r\n    const fetchChatList = useCallback(async () => {\r\n        try {\r\n            const response = await fetch(`${API_BASE_URL}/api/chats`, { // API ROUTE 1\r\n                headers: { 'Authorization': `Bearer ${sessionToken}` }\r\n            });\r\n\r\n            if (response.status === 401) { onSignOut(); return; }\r\n            if (!response.ok) { \r\n                throw new Error(\"API call failed.\"); \r\n            }\r\n            \r\n            const data = await response.json();\r\n            setChatList(data.chats || []);\r\n\r\n            // On initial load logic (only runs once)\r\n            if (initialLoadRef.current) {\r\n                if (data.chats.length > 0) {\r\n                    setCurrentChatId(data.chats[0].id); // Load the most recent chat\r\n                } else {\r\n                    handleNewChat(); // Start a new one if the list is empty\r\n                }\r\n                initialLoadRef.current = false;\r\n            }\r\n\r\n        } catch (err) {\r\n            console.error(\"Error fetching chat list:\", err);\r\n            setError(\"Failed to load chat history. Starting a new chat.\"); \r\n            \r\n            // ðŸ›‘ CRITICAL STABILIZATION: Start a new chat if fetching history fails\r\n            if (initialLoadRef.current) {\r\n                handleNewChat();\r\n                initialLoadRef.current = false;\r\n            }\r\n        }\r\n    }, [sessionToken, onSignOut]);\r\n\r\n    // 2. Fetch messages for a specific chat ID\r\n    const fetchMessages = useCallback(async (chatId) => {\r\n        if (!chatId) return;\r\n        setIsLoading(true);\r\n        setMessages([]); // Clear old messages immediately\r\n\r\n        try {\r\n            const response = await fetch(`${API_BASE_URL}/api/chats/${chatId}/messages`, { // API ROUTE 2\r\n                headers: { 'Authorization': `Bearer ${sessionToken}` }\r\n            });\r\n\r\n            if (response.status === 401) { onSignOut(); return; }\r\n            if (!response.ok) { throw new Error(`Failed to fetch messages.`); }\r\n\r\n            const data = await response.json();\r\n            setMessages(data.messages || []);\r\n            setError('');\r\n        } catch (err) {\r\n            console.error(\"Error fetching messages:\", err);\r\n            setError(err.message);\r\n            setMessages([]);\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    }, [sessionToken, onSignOut]);\r\n\r\n    // 3. Delete a chat\r\n    const handleDeleteChat = async (chatIdToDelete) => {\r\n        if (!window.confirm(\"Are you sure you want to delete this chat history?\")) return;\r\n\r\n        try {\r\n            const response = await fetch(`${API_BASE_URL}/api/chats/${chatIdToDelete}`, { // API ROUTE 3\r\n                method: 'DELETE',\r\n                headers: { 'Authorization': `Bearer ${sessionToken}` }\r\n            });\r\n\r\n            if (response.status === 401) { onSignOut(); return; }\r\n            if (!response.ok) { throw new Error(\"Failed to delete chat.\"); }\r\n\r\n            // Update local state\r\n            setChatList(prev => prev.filter(chat => chat.id !== chatIdToDelete));\r\n            \r\n            // If the deleted chat was the current one, start a new chat\r\n            if (chatIdToDelete === currentChatId) {\r\n                setCurrentChatId(null); \r\n                handleNewChat();\r\n            }\r\n\r\n        } catch (err) {\r\n            console.error(\"Error deleting chat:\", err);\r\n            setError(\"Failed to delete chat history.\");\r\n        }\r\n    };\r\n\r\n\r\n    // B. Logic to load chat list on mount\r\n    useEffect(() => {\r\n        if (sessionToken) {\r\n            fetchChatList();\r\n        }\r\n    }, [sessionToken, fetchChatList]);\r\n\r\n    // C. Logic to load messages when currentChatId changes\r\n    useEffect(() => {\r\n        if (currentChatId) {\r\n            fetchMessages(currentChatId);\r\n        }\r\n    }, [currentChatId, fetchMessages]);\r\n\r\n\r\n    // --- Core Chat Handlers (Modified to use currentChatId) ---\r\n\r\n    const handleSendMessage = async (e) => {\r\n        e.preventDefault();\r\n        const message = input.trim();\r\n        if (!message || isLoading || !currentChatId) return; // Ensures valid ID exists\r\n\r\n        setIsLoading(true);\r\n        setInput('');\r\n        const userMessage = { sender: 'user', text: message, timestamp: new Date().toISOString() };\r\n        setMessages(prev => [...prev, userMessage]);\r\n\r\n        try {\r\n            const response = await fetch(`${API_BASE_URL}/api/chat`, { // Existing chat API\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                    'Authorization': `Bearer ${sessionToken}`\r\n                },\r\n                body: JSON.stringify({ message, chat_id: currentChatId }), // SEND the unique chat_id\r\n            });\r\n\r\n            if (response.status === 401) { onSignOut(); return; }\r\n            \r\n            const data = await response.json();\r\n\r\n            if (!response.ok) {\r\n                throw new Error(data.error || 'Chat response failed.');\r\n            }\r\n            \r\n            const botMessage = { sender: 'bot', text: data.response, timestamp: new Date().toISOString() };\r\n            setMessages(prev => [...prev, botMessage]);\r\n\r\n            // If this was a new chat, update the title in the list\r\n            if (chatList.find(c => c.id === currentChatId)?.title === 'New Chat') {\r\n                setChatList(prev => prev.map(chat => \r\n                    chat.id === currentChatId ? { ...chat, title: data.chat_title || message.substring(0, 25) } : chat\r\n                ));\r\n            }\r\n\r\n        } catch (err) {\r\n            console.error(err);\r\n            setError(err.message);\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    };\r\n    \r\n    // File upload must also be associated with the current chat ID\r\n    const handleFileUpload = async (file) => {\r\n        if (isLoading || !currentChatId) return; // Ensures valid ID exists\r\n\r\n        setIsLoading(true);\r\n        setError('');\r\n\r\n        const formData = new FormData();\r\n        formData.append('file', file);\r\n        formData.append('chat_id', currentChatId); // SEND the unique chat_id\r\n\r\n        try {\r\n            const response = await fetch(`${API_BASE_URL}/upload`, {\r\n                method: 'POST',\r\n                headers: { 'Authorization': `Bearer ${sessionToken}` },\r\n                body: formData,\r\n            });\r\n\r\n            if (response.status === 401) { onSignOut(); return; }\r\n            \r\n            const data = await response.json();\r\n\r\n            if (!response.ok) {\r\n                throw new Error(data.error || 'File upload failed.');\r\n            }\r\n            \r\n            const botMessage = { sender: 'bot', text: data.message, timestamp: new Date().toISOString() };\r\n            setMessages(prev => [...prev, botMessage]);\r\n\r\n        } catch (err) {\r\n            console.error(err);\r\n            setError(err.message);\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    };\r\n\r\n    // Consolidate props for the view component\r\n    const viewProps = {\r\n        user, messages, input, setInput, isLoading, error, chatEndRef, onSignOut,\r\n        handleSendMessage, handleFileUpload,\r\n        // NEW History Props\r\n        currentChatId, chatList, \r\n        setCurrentChatId, // onSelectChat\r\n        handleNewChat,\r\n        onDeleteChat: handleDeleteChat,\r\n    };\r\n\r\n\r\n    return (\r\n        <ChatPageView {...viewProps} />\r\n    );\r\n};\r\n\r\nexport default ChatPage;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}