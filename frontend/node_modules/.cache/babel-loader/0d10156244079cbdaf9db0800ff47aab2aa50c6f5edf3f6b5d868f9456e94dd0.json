{"ast":null,"code":"var _jsxFileName = \"E:\\\\Employee Timesheet chatbot\\\\frontend\\\\src\\\\components\\\\ChatPage\\\\ChatPage.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport './ChatPage.css';\nimport ChatPageView from './ChatPageView';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst API_BASE_URL = 'http://127.0.0.1:5000';\nconst ChatPage = ({\n  user,\n  sessionToken,\n  onSignOut\n}) => {\n  _s();\n  const {\n    chatId: urlChatId\n  } = useParams(); // Get chatId from URL\n  const navigate = useNavigate(); // For programmatic navigation\n\n  const [messages, setMessages] = useState([]);\n  const [input, setInput] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState('');\n  const [currentChatId, setCurrentChatId] = useState(null);\n  const [chatSessions, setChatSessions] = useState([]);\n  const [hasLoadedSessions, setHasLoadedSessions] = useState(false);\n  const [isValidatingSession, setIsValidatingSession] = useState(false);\n  const chatEndRef = useRef(null);\n\n  // Sync URL with current chat ID\n  useEffect(() => {\n    if (currentChatId && currentChatId !== urlChatId) {\n      navigate(`/chat/${currentChatId}`, {\n        replace: true\n      });\n    }\n  }, [currentChatId, urlChatId, navigate]);\n\n  // Fetch chat sessions on component mount\n  useEffect(() => {\n    if (sessionToken) {\n      fetchChatSessions();\n    }\n  }, [sessionToken]);\n\n  // Load chat from URL parameter if provided - FIXED LOGIC\n  useEffect(() => {\n    if (urlChatId && sessionToken && hasLoadedSessions) {\n      loadChatFromUrl(urlChatId);\n    } else if (!urlChatId && hasLoadedSessions && chatSessions.length > 0 && !currentChatId) {\n      // If no URL chat ID but we have sessions, load the most recent one\n      const mostRecentSession = chatSessions[0];\n      setCurrentChatId(mostRecentSession.chat_id);\n      loadChatSession(mostRecentSession.chat_id);\n    } else if (!urlChatId && hasLoadedSessions && chatSessions.length === 0) {\n      // No sessions exist, create a new one automatically\n      createNewChatSession();\n    }\n  }, [urlChatId, sessionToken, hasLoadedSessions, chatSessions, currentChatId]);\n  const loadChatFromUrl = async chatId => {\n    try {\n      setIsValidatingSession(true);\n\n      // First validate the session exists\n      const validationResponse = await fetch(`${API_BASE_URL}/chat/sessions/${chatId}/validate`, {\n        headers: {\n          'Authorization': `Bearer ${sessionToken}`\n        }\n      });\n      if (validationResponse.status === 401) {\n        onSignOut();\n        return;\n      }\n      const validationData = await validationResponse.json();\n      if (validationData.valid) {\n        // Session is valid, load it\n        await loadChatSession(chatId);\n      } else {\n        // Session is invalid, create a new one\n        setError(\"The requested chat session was not found. Created a new session for you.\");\n        await createNewChatSession();\n      }\n    } catch (error) {\n      console.error(\"Error validating chat session:\", error);\n      setError(\"Could not validate chat session. Creating a new one...\");\n      await createNewChatSession();\n    } finally {\n      setIsValidatingSession(false);\n    }\n  };\n  const fetchChatSessions = async () => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/sessions`, {\n        headers: {\n          'Authorization': `Bearer ${sessionToken}`\n        }\n      });\n      if (response.status === 401) {\n        onSignOut();\n        return;\n      }\n      if (!response.ok) {\n        throw new Error(\"Failed to fetch chat sessions.\");\n      }\n      const data = await response.json();\n      setChatSessions(data.sessions || []);\n      setHasLoadedSessions(true);\n    } catch (error) {\n      console.error(\"Error fetching chat sessions:\", error);\n      setError(\"Could not load chat sessions.\");\n      setHasLoadedSessions(true);\n    }\n  };\n  const createNewChatSession = async (sessionName = null) => {\n    try {\n      setIsLoading(true);\n      const response = await fetch(`${API_BASE_URL}/chat/sessions`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${sessionToken}`\n        },\n        body: JSON.stringify({\n          session_name: sessionName || `Chat ${new Date().toLocaleString()}`\n        })\n      });\n      if (response.status === 401) {\n        onSignOut();\n        return;\n      }\n      const data = await response.json();\n      if (!response.ok) {\n        throw new Error(data.error || 'Failed to create chat session.');\n      }\n      setCurrentChatId(data.chat_id);\n      setMessages([]);\n      setError('');\n      await fetchChatSessions(); // Refresh sessions list\n    } catch (err) {\n      console.error(err);\n      setError(err.message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  const loadChatSession = async chatId => {\n    try {\n      setIsLoading(true);\n      const response = await fetch(`${API_BASE_URL}/chat/sessions/${chatId}`, {\n        headers: {\n          'Authorization': `Bearer ${sessionToken}`\n        }\n      });\n      if (response.status === 401) {\n        onSignOut();\n        return;\n      }\n      if (!response.ok) {\n        // If loading fails, the session might not exist\n        if (response.status === 404) {\n          setError(\"Chat session not found.\");\n          await createNewChatSession();\n          return;\n        }\n        throw new Error(\"Failed to load chat session.\");\n      }\n      const data = await response.json();\n      setMessages(data.messages || []);\n      setCurrentChatId(chatId);\n      setError('');\n    } catch (error) {\n      console.error(\"Error loading chat session:\", error);\n      setError(\"Could not load chat session.\");\n      // On error, create a new session\n      await createNewChatSession();\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  const deleteChatSession = async chatId => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/sessions/${chatId}`, {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bearer ${sessionToken}`\n        }\n      });\n      if (response.status === 401) {\n        onSignOut();\n        return;\n      }\n      if (!response.ok) {\n        throw new Error(\"Failed to delete chat session.\");\n      }\n\n      // If we're deleting the current chat, clear the current view and navigate to main chat\n      if (currentChatId === chatId) {\n        setCurrentChatId(null);\n        setMessages([]);\n        navigate('/chat', {\n          replace: true\n        });\n      }\n      await fetchChatSessions(); // Refresh sessions list\n    } catch (error) {\n      console.error(\"Error deleting chat session:\", error);\n      setError(\"Could not delete chat session.\");\n    }\n  };\n\n  // Scroll to bottom when messages change\n  useEffect(() => {\n    var _chatEndRef$current;\n    (_chatEndRef$current = chatEndRef.current) === null || _chatEndRef$current === void 0 ? void 0 : _chatEndRef$current.scrollIntoView({\n      behavior: \"smooth\"\n    });\n  }, [messages]);\n  const handleSendMessage = async e => {\n    e.preventDefault();\n    const userQuery = input.trim();\n    if (!userQuery || isLoading || !sessionToken) return;\n\n    // If no current chat exists, create one first\n    if (!currentChatId) {\n      await createNewChatSession();\n      // Wait a moment for the chat to be created, then send the message\n      setTimeout(() => {\n        sendMessageToChat(userQuery);\n      }, 500);\n      return;\n    }\n    sendMessageToChat(userQuery);\n  };\n  const sendMessageToChat = async userQuery => {\n    setIsLoading(true);\n    setInput('');\n    setError('');\n    const newMessage = {\n      sender: 'user',\n      text: userQuery,\n      timestamp: new Date().toISOString()\n    };\n    setMessages(prev => [...prev, newMessage]);\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${sessionToken}`\n        },\n        body: JSON.stringify({\n          query: userQuery,\n          chat_id: currentChatId\n        })\n      });\n      if (response.status === 401) {\n        onSignOut();\n        return;\n      }\n      const data = await response.json();\n      if (!response.ok) {\n        throw new Error(data.error || 'Failed to get response from chatbot.');\n      }\n      const botMessage = {\n        sender: 'bot',\n        text: data.answer,\n        timestamp: new Date().toISOString()\n      };\n      setMessages(prev => [...prev, botMessage]);\n    } catch (err) {\n      console.error(err);\n      setError(err.message);\n\n      // Add error message to chat\n      const errorMessage = {\n        sender: 'bot',\n        text: \"Sorry, I encountered an error. Please try again.\",\n        timestamp: new Date().toISOString()\n      };\n      setMessages(prev => [...prev, errorMessage]);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  const handleFileUpload = async file => {\n    if (isLoading || !sessionToken) return;\n\n    // If no current chat exists, create one first\n    if (!currentChatId) {\n      await createNewChatSession();\n      // Wait a moment for the chat to be created, then upload the file\n      setTimeout(() => {\n        uploadFileToChat(file);\n      }, 500);\n      return;\n    }\n    uploadFileToChat(file);\n  };\n  const uploadFileToChat = async file => {\n    setIsLoading(true);\n    setError('');\n    const formData = new FormData();\n    formData.append('file', file);\n    try {\n      const response = await fetch(`${API_BASE_URL}/upload`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${sessionToken}`\n        },\n        body: formData\n      });\n      if (response.status === 401) {\n        onSignOut();\n        return;\n      }\n      const data = await response.json();\n      if (!response.ok) {\n        throw new Error(data.error || 'File upload failed.');\n      }\n\n      // Add bot confirmation message\n      const botMessage = {\n        sender: 'bot',\n        text: `✅ ${data.message}`,\n        timestamp: new Date().toISOString()\n      };\n      setMessages(prev => [...prev, botMessage]);\n    } catch (err) {\n      console.error(err);\n      setError(err.message);\n\n      // Add error message to chat\n      const errorMessage = {\n        sender: 'bot',\n        text: \"❌ File upload failed. Please try again.\",\n        timestamp: new Date().toISOString()\n      };\n      setMessages(prev => [...prev, errorMessage]);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Consolidate props for the view component\n  const viewProps = {\n    user,\n    messages,\n    input,\n    setInput,\n    isLoading: isLoading || isValidatingSession,\n    error,\n    chatEndRef,\n    onSignOut,\n    currentChatId,\n    chatSessions,\n    hasLoadedSessions,\n    handleSendMessage,\n    handleFileUpload,\n    createNewChatSession,\n    loadChatSession,\n    deleteChatSession,\n    setError\n  };\n  return /*#__PURE__*/_jsxDEV(ChatPageView, {\n    ...viewProps\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 388,\n    columnNumber: 9\n  }, this);\n};\n_s(ChatPage, \"JRcwUeUIqycD+eCcvtRvEEjAIpY=\", false, function () {\n  return [useParams, useNavigate];\n});\n_c = ChatPage;\nexport default ChatPage;\nvar _c;\n$RefreshReg$(_c, \"ChatPage\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useParams","useNavigate","ChatPageView","jsxDEV","_jsxDEV","API_BASE_URL","ChatPage","user","sessionToken","onSignOut","_s","chatId","urlChatId","navigate","messages","setMessages","input","setInput","isLoading","setIsLoading","error","setError","currentChatId","setCurrentChatId","chatSessions","setChatSessions","hasLoadedSessions","setHasLoadedSessions","isValidatingSession","setIsValidatingSession","chatEndRef","replace","fetchChatSessions","loadChatFromUrl","length","mostRecentSession","chat_id","loadChatSession","createNewChatSession","validationResponse","fetch","headers","status","validationData","json","valid","console","response","ok","Error","data","sessions","sessionName","method","body","JSON","stringify","session_name","Date","toLocaleString","err","message","deleteChatSession","_chatEndRef$current","current","scrollIntoView","behavior","handleSendMessage","e","preventDefault","userQuery","trim","setTimeout","sendMessageToChat","newMessage","sender","text","timestamp","toISOString","prev","query","botMessage","answer","errorMessage","handleFileUpload","file","uploadFileToChat","formData","FormData","append","viewProps","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["E:/Employee Timesheet chatbot/frontend/src/components/ChatPage/ChatPage.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\r\nimport { useParams, useNavigate } from 'react-router-dom';\r\nimport './ChatPage.css'; \r\nimport ChatPageView from './ChatPageView';\r\n\r\nconst API_BASE_URL = 'http://127.0.0.1:5000';\r\n\r\nconst ChatPage = ({ user, sessionToken, onSignOut }) => {\r\n    const { chatId: urlChatId } = useParams(); // Get chatId from URL\r\n    const navigate = useNavigate(); // For programmatic navigation\r\n    \r\n    const [messages, setMessages] = useState([]);\r\n    const [input, setInput] = useState('');\r\n    const [isLoading, setIsLoading] = useState(false);\r\n    const [error, setError] = useState('');\r\n    const [currentChatId, setCurrentChatId] = useState(null);\r\n    const [chatSessions, setChatSessions] = useState([]);\r\n    const [hasLoadedSessions, setHasLoadedSessions] = useState(false);\r\n    const [isValidatingSession, setIsValidatingSession] = useState(false);\r\n    const chatEndRef = useRef(null);\r\n\r\n    // Sync URL with current chat ID\r\n    useEffect(() => {\r\n        if (currentChatId && currentChatId !== urlChatId) {\r\n            navigate(`/chat/${currentChatId}`, { replace: true });\r\n        }\r\n    }, [currentChatId, urlChatId, navigate]);\r\n\r\n    // Fetch chat sessions on component mount\r\n    useEffect(() => {\r\n        if (sessionToken) {\r\n            fetchChatSessions();\r\n        }\r\n    }, [sessionToken]);\r\n\r\n    // Load chat from URL parameter if provided - FIXED LOGIC\r\n    useEffect(() => {\r\n        if (urlChatId && sessionToken && hasLoadedSessions) {\r\n            loadChatFromUrl(urlChatId);\r\n        } else if (!urlChatId && hasLoadedSessions && chatSessions.length > 0 && !currentChatId) {\r\n            // If no URL chat ID but we have sessions, load the most recent one\r\n            const mostRecentSession = chatSessions[0];\r\n            setCurrentChatId(mostRecentSession.chat_id);\r\n            loadChatSession(mostRecentSession.chat_id);\r\n        } else if (!urlChatId && hasLoadedSessions && chatSessions.length === 0) {\r\n            // No sessions exist, create a new one automatically\r\n            createNewChatSession();\r\n        }\r\n    }, [urlChatId, sessionToken, hasLoadedSessions, chatSessions, currentChatId]);\r\n\r\n    const loadChatFromUrl = async (chatId) => {\r\n        try {\r\n            setIsValidatingSession(true);\r\n            \r\n            // First validate the session exists\r\n            const validationResponse = await fetch(`${API_BASE_URL}/chat/sessions/${chatId}/validate`, {\r\n                headers: {\r\n                    'Authorization': `Bearer ${sessionToken}`\r\n                }\r\n            });\r\n\r\n            if (validationResponse.status === 401) {\r\n                onSignOut();\r\n                return;\r\n            }\r\n\r\n            const validationData = await validationResponse.json();\r\n\r\n            if (validationData.valid) {\r\n                // Session is valid, load it\r\n                await loadChatSession(chatId);\r\n            } else {\r\n                // Session is invalid, create a new one\r\n                setError(\"The requested chat session was not found. Created a new session for you.\");\r\n                await createNewChatSession();\r\n            }\r\n        } catch (error) {\r\n            console.error(\"Error validating chat session:\", error);\r\n            setError(\"Could not validate chat session. Creating a new one...\");\r\n            await createNewChatSession();\r\n        } finally {\r\n            setIsValidatingSession(false);\r\n        }\r\n    };\r\n\r\n    const fetchChatSessions = async () => {\r\n        try {\r\n            const response = await fetch(`${API_BASE_URL}/chat/sessions`, {\r\n                headers: {\r\n                    'Authorization': `Bearer ${sessionToken}`\r\n                }\r\n            });\r\n\r\n            if (response.status === 401) {\r\n                onSignOut(); \r\n                return;\r\n            }\r\n\r\n            if (!response.ok) {\r\n                throw new Error(\"Failed to fetch chat sessions.\");\r\n            }\r\n\r\n            const data = await response.json();\r\n            setChatSessions(data.sessions || []);\r\n            setHasLoadedSessions(true);\r\n\r\n        } catch (error) {\r\n            console.error(\"Error fetching chat sessions:\", error);\r\n            setError(\"Could not load chat sessions.\");\r\n            setHasLoadedSessions(true);\r\n        }\r\n    };\r\n\r\n    const createNewChatSession = async (sessionName = null) => {\r\n        try {\r\n            setIsLoading(true);\r\n            const response = await fetch(`${API_BASE_URL}/chat/sessions`, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                    'Authorization': `Bearer ${sessionToken}`\r\n                },\r\n                body: JSON.stringify({ \r\n                    session_name: sessionName || `Chat ${new Date().toLocaleString()}`\r\n                })\r\n            });\r\n\r\n            if (response.status === 401) {\r\n                onSignOut();\r\n                return;\r\n            }\r\n\r\n            const data = await response.json();\r\n\r\n            if (!response.ok) {\r\n                throw new Error(data.error || 'Failed to create chat session.');\r\n            }\r\n\r\n            setCurrentChatId(data.chat_id);\r\n            setMessages([]);\r\n            setError('');\r\n            await fetchChatSessions(); // Refresh sessions list\r\n\r\n        } catch (err) {\r\n            console.error(err);\r\n            setError(err.message);\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    };\r\n\r\n    const loadChatSession = async (chatId) => {\r\n        try {\r\n            setIsLoading(true);\r\n            const response = await fetch(`${API_BASE_URL}/chat/sessions/${chatId}`, {\r\n                headers: {\r\n                    'Authorization': `Bearer ${sessionToken}`\r\n                }\r\n            });\r\n\r\n            if (response.status === 401) {\r\n                onSignOut();\r\n                return;\r\n            }\r\n\r\n            if (!response.ok) {\r\n                // If loading fails, the session might not exist\r\n                if (response.status === 404) {\r\n                    setError(\"Chat session not found.\");\r\n                    await createNewChatSession();\r\n                    return;\r\n                }\r\n                throw new Error(\"Failed to load chat session.\");\r\n            }\r\n\r\n            const data = await response.json();\r\n            setMessages(data.messages || []);\r\n            setCurrentChatId(chatId);\r\n            setError('');\r\n\r\n        } catch (error) {\r\n            console.error(\"Error loading chat session:\", error);\r\n            setError(\"Could not load chat session.\");\r\n            // On error, create a new session\r\n            await createNewChatSession();\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    };\r\n\r\n    const deleteChatSession = async (chatId) => {\r\n        try {\r\n            const response = await fetch(`${API_BASE_URL}/chat/sessions/${chatId}`, {\r\n                method: 'DELETE',\r\n                headers: {\r\n                    'Authorization': `Bearer ${sessionToken}`\r\n                }\r\n            });\r\n\r\n            if (response.status === 401) {\r\n                onSignOut();\r\n                return;\r\n            }\r\n\r\n            if (!response.ok) {\r\n                throw new Error(\"Failed to delete chat session.\");\r\n            }\r\n\r\n            // If we're deleting the current chat, clear the current view and navigate to main chat\r\n            if (currentChatId === chatId) {\r\n                setCurrentChatId(null);\r\n                setMessages([]);\r\n                navigate('/chat', { replace: true });\r\n            }\r\n\r\n            await fetchChatSessions(); // Refresh sessions list\r\n\r\n        } catch (error) {\r\n            console.error(\"Error deleting chat session:\", error);\r\n            setError(\"Could not delete chat session.\");\r\n        }\r\n    };\r\n\r\n    // Scroll to bottom when messages change\r\n    useEffect(() => {\r\n        chatEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\r\n    }, [messages]);\r\n\r\n    const handleSendMessage = async (e) => {\r\n        e.preventDefault();\r\n        const userQuery = input.trim();\r\n        \r\n        if (!userQuery || isLoading || !sessionToken) return;\r\n        \r\n        // If no current chat exists, create one first\r\n        if (!currentChatId) {\r\n            await createNewChatSession();\r\n            // Wait a moment for the chat to be created, then send the message\r\n            setTimeout(() => {\r\n                sendMessageToChat(userQuery);\r\n            }, 500);\r\n            return;\r\n        }\r\n        \r\n        sendMessageToChat(userQuery);\r\n    };\r\n\r\n    const sendMessageToChat = async (userQuery) => {\r\n        setIsLoading(true);\r\n        setInput('');\r\n        setError('');\r\n\r\n        const newMessage = { sender: 'user', text: userQuery, timestamp: new Date().toISOString() };\r\n        setMessages(prev => [...prev, newMessage]);\r\n\r\n        try {\r\n            const response = await fetch(`${API_BASE_URL}/chat`, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                    'Authorization': `Bearer ${sessionToken}`\r\n                },\r\n                body: JSON.stringify({ \r\n                    query: userQuery, \r\n                    chat_id: currentChatId\r\n                }),\r\n            });\r\n\r\n            if (response.status === 401) {\r\n                onSignOut();\r\n                return;\r\n            }\r\n            \r\n            const data = await response.json();\r\n\r\n            if (!response.ok) {\r\n                throw new Error(data.error || 'Failed to get response from chatbot.');\r\n            }\r\n\r\n            const botMessage = { sender: 'bot', text: data.answer, timestamp: new Date().toISOString() };\r\n            setMessages(prev => [...prev, botMessage]);\r\n\r\n        } catch (err) {\r\n            console.error(err);\r\n            setError(err.message);\r\n            \r\n            // Add error message to chat\r\n            const errorMessage = { \r\n                sender: 'bot', \r\n                text: \"Sorry, I encountered an error. Please try again.\", \r\n                timestamp: new Date().toISOString() \r\n            };\r\n            setMessages(prev => [...prev, errorMessage]);\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    };\r\n\r\n    const handleFileUpload = async (file) => {\r\n        if (isLoading || !sessionToken) return;\r\n        \r\n        // If no current chat exists, create one first\r\n        if (!currentChatId) {\r\n            await createNewChatSession();\r\n            // Wait a moment for the chat to be created, then upload the file\r\n            setTimeout(() => {\r\n                uploadFileToChat(file);\r\n            }, 500);\r\n            return;\r\n        }\r\n        \r\n        uploadFileToChat(file);\r\n    };\r\n\r\n    const uploadFileToChat = async (file) => {\r\n        setIsLoading(true);\r\n        setError('');\r\n        \r\n        const formData = new FormData();\r\n        formData.append('file', file);\r\n        \r\n        try {\r\n            const response = await fetch(`${API_BASE_URL}/upload`, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Authorization': `Bearer ${sessionToken}` \r\n                },\r\n                body: formData,\r\n            });\r\n\r\n            if (response.status === 401) {\r\n                onSignOut();\r\n                return;\r\n            }\r\n            \r\n            const data = await response.json();\r\n\r\n            if (!response.ok) {\r\n                throw new Error(data.error || 'File upload failed.');\r\n            }\r\n            \r\n            // Add bot confirmation message\r\n            const botMessage = { \r\n                sender: 'bot', \r\n                text: `✅ ${data.message}`, \r\n                timestamp: new Date().toISOString() \r\n            };\r\n            setMessages(prev => [...prev, botMessage]);\r\n\r\n        } catch (err) {\r\n            console.error(err);\r\n            setError(err.message);\r\n            \r\n            // Add error message to chat\r\n            const errorMessage = { \r\n                sender: 'bot', \r\n                text: \"❌ File upload failed. Please try again.\", \r\n                timestamp: new Date().toISOString() \r\n            };\r\n            setMessages(prev => [...prev, errorMessage]);\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    };\r\n\r\n    // Consolidate props for the view component\r\n    const viewProps = {\r\n        user, \r\n        messages, \r\n        input, \r\n        setInput, \r\n        isLoading: isLoading || isValidatingSession, \r\n        error, \r\n        chatEndRef, \r\n        onSignOut,\r\n        currentChatId, \r\n        chatSessions, \r\n        hasLoadedSessions,\r\n        handleSendMessage, \r\n        handleFileUpload,\r\n        createNewChatSession, \r\n        loadChatSession, \r\n        deleteChatSession,\r\n        setError\r\n    };\r\n\r\n    return (\r\n        <ChatPageView {...viewProps} />\r\n    );\r\n};\r\n\r\nexport default ChatPage;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}